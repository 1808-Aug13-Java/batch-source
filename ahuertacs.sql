-- we can create a comment like this
/*
this is a multiline comment
we can comment on this line too
*/

-------------------------------------
-- USING DDL TO CREATE OUR TABLES
-------------------------------------
CREATE TABLE DEPARTMENT(
    DEPT_ID NUMBER(5) CONSTRAINT PK_DEPT PRIMARY KEY,
    DEPT_NAME VARCHAR2(50),
    MONTHLY_BUDGET NUMBER(7,2)
);

CREATE TABLE EMPLOYEE (
    EMP_ID NUMBER(5) CONSTRAINT PK_EMP PRIMARY KEY,
    EMP_NAME VARCHAR2(50),
    BIRTHDAY DATE,
    MONTHLY_SALARY NUMBER(7,2) NOT NULL,
    HIRE_DATE DATE,
    POSITION VARCHAR2(20),
    MANAGER_ID NUMBER(5),
    DEPT_ID NUMBER(5) CONSTRAINT FK_EMP_DPT REFERENCES DEPARTMENT
);

-- We can't first insert to our employee table with a department without first defining the department
-- INSERT INTO EMPLOYEE VALUES (1, 'JOHN SMITH', DATE '1989-01-05', 2000, DATE '2015-03-08', 'MK_REP',NULL,1);

-- INSERTING RECORDS INTO OUR DEPARTMENT TABLE
INSERT INTO DEPARTMENT VALUES (1, 'MARKETING', 5000);
INSERT INTO DEPARTMENT VALUES (2, 'ACCOUNTING', 4000);
INSERT INTO DEPARTMENT VALUES (3, 'INFORMATION TECHNOLOGY', 4500);
INSERT INTO DEPARTMENT VALUES (4, 'HUMAN RESOURCED', 3500);
INSERT INTO DEPARTMENT VALUES (5, 'LEGAL', 2000);
INSERT INTO DEPARTMENT VALUES (6, 'CUSTOMER SERVICE', 3000);
-- INSERT INTO DEPARTMENT (DEPT_ID, DEPT_NAME) VALUES (7, 'SALES'); 

-- WHEN ATTEMPTING TO DROP A TABLE WHICH IS REFERENCED BY ANOTHER WE ARE UNABLE TO DO SO
DROP TABLE DEPARTMENT;

-- WE ARE ABLE TO DROP THE TABLE ONCE THE RELATIONSHIP IS REMOVED
ALTER TABLE EMPLOYEE 
DROP CONSTRAINT FK_EMP_DPT;

-- DROP TABLE DEPARTMENT;

-- RE-CREATING OUR FOREIGN KEY RELATIONSHIP 
ALTER TABLE EMPLOYEE
ADD CONSTRAINT FK_EMP_DPT
FOREIGN KEY (DEPT_ID) REFERENCES DEPARTMENT(DEPT_ID) ON DELETE CASCADE;
-- ANOTHER OPTION HERE IS 'ON DELETE SET NULL' 

-- INSERT SOME EMPLOYEES INTO OUR EMPLOYEE TABLE (DML)
INSERT INTO EMPLOYEE VALUES (1, 'JOHN SMITH', DATE '1989-01-05', 2000, DATE '2015-03-08', 'MK_REP',NULL,1);
INSERT INTO EMPLOYEE VALUES (2, 'JAMES BOSH', DATE '1990-08-13', 3200, DATE '2013-02-20', 'AC_ACCOUNT',NULL,2);
INSERT INTO EMPLOYEE VALUES (3, 'LISA JACKSON', DATE '1988-10-15', 3800, DATE '2012-03-08', 'IT_PROF',NULL,3);
INSERT INTO EMPLOYEE VALUES (4, 'ANGELA DEAN', DATE '1982-12-07', 2000, DATE '2017-04-12', 'IT_PROF',3,3);
INSERT INTO EMPLOYEE VALUES (5, 'NIGEL OAKS', DATE '1990-07-28', 2200, DATE '2018-07-20', 'MK_REP',1,1);
INSERT INTO EMPLOYEE VALUES (6, 'JAMES BOND', DATE '1992-11-13', 2800, DATE '2017-10-03', 'MK_REP',1,1);

SELECT EMP_NAME
FROM EMPLOYEE;

SELECT *
FROM EMPLOYEE;

DELETE FROM EMPLOYEE
WHERE MONTHLY_SALARY>3500;

DELETE FROM EMPLOYEE
WHERE EMP_ID=3;

------------------------------------
-- QUERYING THE DATABASE
------------------------------------

SELECT * 
FROM EMPLOYEE 
WHERE MANAGER_ID=1;

SELECT EMP_NAME, MONTHLY_SALARY, HIRE_DATE
FROM EMPLOYEE 
WHERE MANAGER_ID=1;

SELECT *
FROM EMPLOYEE 
WHERE EMP_NAME LIKE 'JAMES%'
ORDER BY MONTHLY_SALARY DESC;

SELECT COUNT(*) AS TOTAL_EMPLOYEES
FROM EMPLOYEE;

-- SHOW THE AVERAGE SALARY BY DEPARTMENT
SELECT DEPT_ID DEPT, ROUND(AVG(MONTHLY_SALARY)) AVG_SALARY
FROM EMPLOYEE
GROUP BY DEPT_ID
HAVING DEPT_ID<3;

--INNER JOIN
SELECT
    E.EMP_NAME AS NAME,
    D.DEPT_NAME AS DEPARTMENT
FROM EMPLOYEE E
INNER JOIN DEPARTMENT D
ON E.DEPT_ID = D.DEPT_ID;

--IMPLCIT INNER JOIN
SELECT
    E.EMP_NAME AS NAME,
    D.DEPT_NAME AS DEPARTMENT
FROM EMPLOYEE E, DEPARTMENT D
WHERE E.DEPT_ID = D.DEPT_ID;

--RIGHT JOIN
SELECT 
    E.EMP_NAME AS NAME,
    D.DEPT_NAME AS DEPARTMENT
    FROM EMPLOYEE E
    RIGHT JOIN DEPARTMENT D
    ON E.DEPT_ID = D.DEPT_ID;
   
 --SELF JOIN USING AN IMPLICIT INNER JOIN
SELECT EMP1.EMP_NAME AS EMPLOYEE, EMP2.EMP_NAME AS MANAGER
FROM EMPLOYEE EMP1, EMPLOYEE EMP2
WHERE EMP1.MANAGER_ID = EMP2.EMP_ID; 
 
--CROSS JOIN WITH EVERY EMPLOYEE AND DEPARTMENT
SELECT EMP_NAME, DEPT_NAME
FROM EMPLOYEE
CROSS JOIN DEPARTMENT;
 
--NATURAL JOIN
SELECT *
FROM EMPLOYEE
NATURAL JOIN DEPARTMENT;

SELECT *
FROM EMPLOYEE
JOIN DEPARTMENT
ON EMPLOYEE.DEPT_ID = DEPARTMENT.DEPT_ID;

-- OUTER JOIN WITH LOCATIONS AND EMPLOYEES // ACCIDENTALLY DELETED LOCATIONS SO IT WILL NOT COMPILE
SELECT *
FROM LOCATIONS
OUTER JOIN EMPLOYEE
ON EMPLOYEE.LOCATION_ID=LOCATIONS.LOCATION_ID;

--WE CAN STACK JOIN AND JOIN FROM MORE THAN ONE TABLE, QUERING INFORMATION FROM ALL THREE
SELECT
    E.EMP_NAME NAME,
    D.DEPT_NAME DEPARTMENT,
    CONCAT(CONCAT(L.CITY,', '),L.STATE) LOCATION
FROM EMPLOYEE
INNER JOIN DEPARTMENT
ON E.DEPT_NAME = D.DEPT_ID
INNER JOIN LOCATIONS L
ON L.LOCATIONS_ID=E.LOCATION_ID;

CREATE VIEW MANAGERS AS
SELECT EMP1.EMP_NAME AS EMPLOYEE, EMP2.EMP_NAME AS MANAGER
FROM EMPLOYEE EMP1, EMPLOYEE EMP2
WHERE EMP1.MANAGER_ID = EMP2.EMP_ID;

------------------------------
--SET OPERATORS
------------------------------

SELECT *
FROM EMPLOYEE
WHERE DEPT_ID=1
UNION --INTERSECT, UNIONE ALL, MINUS ETC.....
SELECT *
FROM EMPLOYEE
WHERE LOCATION_=1;

------------------------------
--USING IN AND EXISTS WITH SUBQUERIES
------------------------------
SELECT *
FROM DEPARTMENT
WHERE EXISTS (
    SELECT *
    FROM EMPLOYEE
    WHERE EMPLOYE.DEPT_ID = DEPARTMENT.DEPT_ID
    );
/*
EXISTS VS IN
EXISTS IS GOING TO EVALUTE TO A BOOLEAN, WHEREAS IN IS GOING TO RETURN A RESULT
EXISTS RUNS THE INNER QUER ONE FOR EVERY RECORD IN THE OUTER QUERY
IF (RESULTS OF THE OUTER QUERY > RESULTS OF THE INNER QUERY IN IS MORE EFFICIENT
*/

COMMIT;

SELECT STREET STREET1, CITY CITY1, STATE STATE1
FROM LOCATINS;

SAVEPOINT SP1;

UPDATE LOCATIONS
SET CITY = 'KANSAS CITY'

SELECT STREET STREET2, CITY CITY2, STATE STATE2
FROM LOCATIONS;
ROLLBACK TO SP1;

UPDATE LOCATIONS SET 
CITY='OKLAHOMA CITY'
WHERE LOCATIONS_ID=3;

SELECT STREET STREET3, CITY CITY3,STATE STATE3
FROM LOCATIONS;

ROLLBACK;
COMMIT;
SELECT STREET STREET 4, CITY CITY4, STATE STATE4
FROM LOCATIONS;

------------------------
--Wednesday Excercises
------------------------ 

--A. Create a query which returns all of the invoices which have a listed customer, but not invoices who have no customer listed and not customers who have no invoices listed
--

SELECT INVOICE_ID
FROM INVOICE
WHERE CUSTOMER_ID >= 1
MINUS
SELECT INVOICE_ID
FROM INVOICE
WHERE INVOICE_ID <= 0
ORDER BY INVOICE_ID;

/*
UPDATE INVOICE
SET INVOICE_ID = NULL
WHERE INVOICE_ID = 10;
*/

--B. Create a query which returns all of the invoices and their customer, not invoices who have no customer listed but include customers which have no invoices listed
SELECT *
FROM INVOICE I
RIGHT JOIN CUSTOMER C
ON I.CUSTOMER_ID = C.CUSTOMER_ID;

--C. Create a query which shows each record in the invoice table, along with the name of the customer
SELECT *
FROM INVOICE I
LEFT JOIN CUSTOMER C
ON I.CUSTOMER_ID = C.CUSTOMER_ID;

--D. Create a query which shows the name of each customer and the total amount they have spent
SELECT CUSTOMER_NAME, SUM (I.AMOUNT)
FROM CUSTOMER C, INVOICE I
WHERE C.CUSTOMER_ID = I.CUSTOMER_ID
GROUP BY C.CUSTOMER_NAME;

--E. Create a query which returns the record of the customer who made the most recent purchase

SELECT CUSTOMER_NAME, INVOICE_DATE
FROM (SELECT * 
FROM CUSTOMER C, INVOICE I
ORDER BY I.INVOICE_DATE DESC)
WHERE ROWNUM = 1;

--F. Create a query which shows the purchaser of each invoice and the subtotal of each invoice if 6% sales tax was applied to the subtotal to get the price of each invoice
SELECT CUSTOMER_NAME, INVOICE_DATE, (I.AMOUNT * 1.06)
FROM CUSTOMER C, INVOICE I
--ORDER BY I.AMOUNT
WHERE C.CUSTOMER_ID = I.CUSTOMER_ID
ORDER BY I.AMOUNT;


-- CREATE A FUNCTION WHICH CALCULATES THE SUBTOTAL OF A GIVEN TOTAL, IF THE TOTAL IS EQUAL TO THE SUBTOTAL WITH 6% TAX - USE IT TO RECREATE THE QUERY FROM YESTERDAY
CREATE OR REPLACE FUNCTION APPLY_SUBTOTAL(SUBTOTAL IN NUMBER)
RETURN NUMBER
IS
BEGIN
    RETURN ROUND((SUBTOTAL/1.06),2);
END;
/

SELECT APPLY_SUBTOTAL(I.AMOUNT)
FROM INVOICE I;

--CREATE A FUNCTION WHICH TAKES IN A STRING AND A NUMBER, AND CONCATINATES THAT 
--STRING THAT NUMBER OF TIMES WITH A SPACE BETWEEN EACH AND RETURNS THE RESULT 

/* SOLUTION
CREATE OR REPLACE FUNCTION CONCAT_NUM(TEXT VARCHAR2, NUM_OF_TIMES NUMBER)
RETURN VARCHAR2
IS
    ADDITION_TEXT VARCHAR2(100) := TEXT;
BEGIN
    FOR i in 1..NUM_OF_TIMES-1 LOOP
        ADDITION_TEXT := ADDITION_TEXT || ' ' || TEXT;
    END LOOP;
    RETURN ADDITION_TEXT;
END;
/
*/
CREATE OR REPLACE FUNCTION REPEATER(STR VARCHAR2, NMBR NUMBER)
RETURN VARCHAR2
IS
   COUNTER NUMBER;
   REPEATED VARCHAR2(150);
   BEGIN
   REPEATED:=STR;
   COUNTER:=NMBR;
   LOOP
   COUNTER:= COUNTER-1;
   REPEATED:= (REPEATED, '');
   DBMS_OUTPUT.PUT_LINE(REPEATED||''|| REPEATED);
   EXIT WHEN COUNTER=0;
   END LOOP;
   RETURN REPEATED;
   END;
/

--SELECT 5 AS "NUMBER",REPEATER(5) AS NUMBERSQUARED
--FROM DUAL;
SELECT 5 AS "COUNTER", REPEATER('CAT',2)
FROM DUAL;

------------------
--CREATE A STORED PROCEDURE WHICH CHECK ALL OF THE INVOICES IN YOUR DATABASE AND DELETES ALL ORPHAN RECORDS IN YOUR INVOICE TABLE
------------------
/*
CREATE OR REPLACE PROCEDURE DELETE_ORPHAN

IS

BEGIN

   DELETE (SELECT * FROM INVOICE WHERE CUSTOMER_ID IS NULL);

END;

/

BEGIN
   DELETE_ORPHAN();
END;
*/

------------------
-- CREATE A STORED PROCEDURE WHICH ENTERS A NEW INVOICE INTO THE INVOICE TABLE 
--IF THE DATE IS IN THE FUTURE, IT SHOULD NOT BE ENTERED AND A MESSAGE SHOULD BE PRINTED TO THE CONSOLE
--IN ADDITION IF THE VALUE OF THE INVOICE IS NEGATIVE, IT SHOULD NOT BE ENTERED INTO THE TABLE AND A MESSAGE
--SHOULD BE PRINTED TO THE CONSOLE
------------------



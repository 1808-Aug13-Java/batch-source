-------------------------------------------------------
--FIRST TRY AT SQL, CLASS EXAMPLES
-------------------------------------------------------
CREATE TABLE DEPARTMENT( 
    DEPT_ID NUMBER(5) CONSTRAINT PK_DEPT PRIMARY KEY, 
    DEPT_NAME VARCHAR2(50),  
    MONTHLY_BUDGET NUMBER(7,2) 
); 


CREATE TABLE EMPLOYEE (
    EMP_ID NUMBER(5) CONSTRAINT PK_EMP PRIMARY KEY,
    EMP_NAME VARCHAR2(50),
    BIRTHDAY DATE,
    MONTHLY_SALARY NUMBER(7,2),
    HIRE_DATE DATE,
    POSITION VARCHAR2(20),
    MANAGER_ID NUMBER(5),
    DEPT_ID NUMBER(5) CONSTRAINT FK_EMP_DPT REFERENCES DEPARTMENT
);

--INSERTING RECORDS INTO OUR DEPARTMENT TABLE
INSERT INTO DEPARTMENT VALUES (1, 'MARKETING', 5000);
INSERT INTO DEPARTMENT VALUES (2, 'ACCOUNTING', 4000);
INSERT INTO DEPARTMENT VALUES(3, 'INFORMATION TECHNOLOGY', 4500);
INSERT INTO DEPARTMENT VALUES (4, 'HUMAN RESOURCES', 3500);
INSERT INTO DEPARTMENT VALUES (5, 'LEGAL', 2000);
INSERT INTO DEPARTMENT VALUES(6, 'CUSTOMER SERVICE', 3000);
INSERT INTO DEPARTMENT (DEPT_ID, DEPT_NAME) VALUES (7, 'SALES');

--WHEN ATTEMPTING TO DROP A TABLE WHICH IS REFERENCED BY ANOTHER WE ARE UNABLE TO DO SO
--DROP TABLE DEPARTMENT; WOULD NOT WORK

ALTER TABLE EMPLOYEE
DROP CONSTRAINT FK_EMP_DPT;

--NOW DROP TABLE WORKS
DROP TABLE DEPARTMENT;

--YOU CAN JUST RE-RUN THE CREATE TABLE TO GET IT BACK

--RECREATING OUR FOREIGN KEY RELATIONSHIP
ALTER TABLE EMPLOYEE
ADD CONSTRAINT FK_EMP_DPT 
FOREIGN KEY (DEPT_ID) REFERENCES DEPARTMENT (DEPT_ID) ON DELETE CASCADE;
--ON DELETE CASCADE MEANS IT HAPPENS IN A CHAIN REACTION (ALL EMPLOYEES
--WOULD BE DELETED AS WELL)
--ANOTHER OPTION IS 'ON DELETE SET NULL' WHICH WOULD PRESERVE EMPS

--INSERT SOME EMPLOYEES INTO EMPLOYEE TABLE (DML SUBLANGUAGE)
INSERT INTO EMPLOYEE VALUES(1, 'JOHN SMITH', DATE '1989-01-05', 2000, DATE '2015-03-08', 'MK_REP', NULL,1);
INSERT INTO EMPLOYEE VALUES(2, 'JAMES BOSH', DATE '1990-08-13', 3200, DATE '2013-02-20', 'AC_ACCOUNT', NULL,2);
INSERT INTO EMPLOYEE VALUES(3, 'LISA JACKS', DATE '1988-10-15', 3800, DATE '2012-03-18', 'IT_PROF', NULL,3);
INSERT INTO EMPLOYEE VALUES(4, 'ANGELA DEAN', DATE '1982-12-07', 2000, DATE '2017-05-12', 'IT_PROF', 3,3);
INSERT INTO EMPLOYEE VALUES(5, 'NIGEL OAKS', DATE '1990-07-28', 2200, DATE '2018-07-20', 'MK_REP', 1,1);
INSERT INTO EMPLOYEE VALUES(6, 'JAMES BOND', DATE '1992-11-13', 2800, DATE '2017-10-03', 'MK_REP',1,1);

SELECT *
FROM EMPLOYEE;

DELETE FROM EMPLOYEE
WHERE MONTHLY_SALARY > 3500;

DELETE FROM EMPLOYEE
WHERE EMP_ID = 3;

---------------------------------------
--QUERYING THE DATABASE
---------------------------------------
SELECT *
FROM EMPLOYEE
WHERE MANAGER_ID = 1;

SELECT EMP_NAME, MONTHLY_SALARY, HIRE_DATE
FROM EMPLOYEE
WHERE MANAGER_ID = 1;

SELECT *
FROM EMPLOYEE
WHERE EMP_NAME LIKE 'JAMES%'
ORDER BY MONTHLY_SALARY DESC;

--TO GET TOTAL NUMBER OF EMPLOYEES, USE COUNT FUNCTION; AS KEYWORD ALLOWS DISPLAY
--TO NOT BE COUNT(*) BUT RATHER A TITLE OR 'ALIAS' WE PICK
--EXCEPT YOU DON'T EVEN HAVE TO USE 'AS', YOU CAN JUST THE ALIAS THERE
SELECT COUNT(*) AS TOTAL_EMPLOYEES
FROM EMPLOYEE;

--SHOW AVERAGE SALARY BY DEPARTMENT
SELECT DEPT_ID, ROUND(AVG(MONTHLY_SALARY)) AS AVG_SALARY
FROM EMPLOYEE
GROUP BY DEPT_ID
HAVING DEPT_ID < 3;

SELECT *
FROM EMPLOYEE
WHERE DEPT_ID = 1 OR DEPT_ID = 3 OR DEPT_ID = 6;
--SHORTER WAY TO THE SAME RESULTS
SELECT *
FROM EMPLOYEE
WHERE DEPT_ID IN (1,3,6);

--NESTING QUERIES AKA USING SUBQUERIES
SELECT * 
FROM EMPLOYEE
WHERE MONTHLY_SALARY = 
    (SELECT MAX(MONTHLY_SALARY) 
    FROM EMPLOYEE);
    
--LOCATION, PK, FK, ADD RECORDS INTO TABLE, REFACTOR EMPLOYEES TO ACCOMMODATE LOCATION TABLE

CREATE TABLE LOCATIONS (
    SITE_ST_NUM NUMBER(5),
    SITE_ST_NAME VARCHAR2(50),
    SITE_CITY VARCHAR(30),
    SITE_STATE VARCHAR2(2),
    SITE_ZIP NUMBER(5),
    SITE_NAME VARCHAR(20),
    SITE_ID NUMBER(5) CONSTRAINT PK_SITE PRIMARY KEY
);    

--ADD EMPLOYEE SITE_ID TO EMPLOYEE TABLE
ALTER TABLE EMPLOYEE
ADD SITE_ID NUMBER(5);

--ADD RELATIONSHIP BETWEEN EMPLOYEE AND LOCATION
ALTER TABLE EMPLOYEE
ADD CONSTRAINT FK_EMP_SITE
FOREIGN KEY (SITE_ID) REFERENCES LOCATIONS;

SELECT *
FROM LOCATIONS;

INSERT INTO LOCATIONS VALUES (1808, 'FIRST STREET', 'HUNTSVILLE', 'AL', 35816, 'CORPORATE HQ', 1);
INSERT INTO LOCATIONS VALUES (1305, 'TOWER ST', 'PACIFIC', 'M0', 63069, 'FIRST BRANCH', 2);
INSERT INTO LOCATIONS VALUES (3314, 'E 6TH ST', 'TULSA', 'OK', 74112, 'TULSA SATELLITE', 3);

--INSERT DATA INTO EMPLOYEE VALUES
INSERT INTO EMPLOYEE VALUES (7, 'JILLIAN KYND', DATE '1980-10-15', 2840.00, DATE '2015-05-11', 'AC_ACCOUNT', 2, 2, 1);
INSERT INTO EMPLOYEE VALUES (8, 'TIM KIBBEL', DATE '1980-05-20', 2240.00, DATE '2014-07-28', 'MK_REP', 1, 1, 1);
INSERT INTO EMPLOYEE VALUES (9, 'ETHELIN COMINI', DATE '1982-06-16', 3380.00, DATE '2017-10-02', 'IT_DEV', 3, 3, 1);
INSERT INTO EMPLOYEE VALUES (10, 'JASE HANDLEY', DATE '1975-10-08', 1870.00, DATE '2017-08-17', 'LG_LAW',11, 5, 1);
INSERT INTO EMPLOYEE VALUES (11, 'ARIEL PAVIS', DATE '1981-09-23', 4500.00, DATE '2015-07-12', 'LG_LAW', NULL, 5, 2);
INSERT INTO EMPLOYEE VALUES (12, 'MELISSA ITZKOVSKY', DATE '1983-03-03', 3870.00, DATE '2014-09-15', 'LG_LAW',11, 5, 2);
INSERT INTO EMPLOYEE VALUES (13, 'MALIA FILISOV', DATE '1976-07-11', 4620.00, DATE '2014-11-09', 'CS_REP', NULL, 6, 2);
INSERT INTO EMPLOYEE VALUES (14, 'BRENDAN LOUISET', DATE '1979-01-21', 3760.00, DATE '2018-03-28', 'CS_REP',13, 6, 2);
INSERT INTO EMPLOYEE VALUES (15, 'MILT KLIEMANN', DATE '1983-02-25', 3820.00, DATE '2016-05-01', 'AC_ACCOUNT', 2, 2, 2);
INSERT INTO EMPLOYEE VALUES (16, 'LUCILLE HUNE', DATE '1994-01-04', 2300.00, DATE '2016-04-17', 'MK_REP',1, 1, 2);
INSERT INTO EMPLOYEE VALUES (17, 'PETA POLTZOLD', DATE '1990-09-24', 2500.00, DATE '2015-07-10', 'IT_DEV',3, 3, 3);
INSERT INTO EMPLOYEE VALUES (18, 'LYDIA POVER', DATE '1991-10-01', 2800.00, DATE '2016-08-03', 'IT_DEV', 17, 3, 3);
INSERT INTO EMPLOYEE VALUES (19, 'RON WINTERTON', DATE '1977-09-27', 2500.00, DATE '2018-02-23', 'LG_LAW', 11, 5, 3);
INSERT INTO EMPLOYEE VALUES (20, 'NITIN CHESTNUT', DATE '1995-01-18', 2800.00, DATE '2014-10-25', 'CS_REP', 13, 6, 3);

SELECT *
FROM DEPARTMENT;

--INNER JOIN
SELECT
    E.EMP_NAME AS NAME,
    D.DEPT_NAME AS DEPARTMENT
FROM EMPLOYEE E
INNER JOIN DEPARTMENT D
ON E.DEPT_ID = D.DEPT_ID;

--IMPLICIT INNER JOIN
SELECT
    E.EMP_NAME AS NAME,
    D.DEPT_NAME AS DEPARTMENT
FROM EMPLOYEE E, DEPARTMENT D
WHERE E.DEPT_ID = D.DEPT_ID;

--FULL OUTER JOIN
SELECT
    E.EMP_NAME AS NAME,
    D.DEPT_NAME AS DEPARTMENT
FROM EMPLOYEE E
FULL JOIN DEPARTMENT D
ON E.DEPT_ID = D.DEPT_ID;

--LEFT JOIN
SELECT
    E.EMP_NAME AS NAME,
    D.DEPT_NAME AS DEPARTMENT
FROM EMPLOYEE E
LEFT JOIN DEPARTMENT D
ON E.DEPT_ID = D.DEPT_ID;

--RIGHT JOINT
SELECT
    E.EMP_NAME AS NAME,
    D.DEPT_NAME AS DEPARTMENT
FROM EMPLOYEE E
RIGHT JOIN DEPARTMENT D
ON E.DEPT_ID = D.DEPT_ID;

--SELF JOIN, NO EXPLICIT SELF-JOIN KEYWORD
/*SELECT [COLUMNS]
FROM [TABLE]
WHERE [PREDICATE] */
CREATE VIEW MANAGERS AS
SELECT
    E1.EMP_NAME EMPLOYEE,
    E2.EMP_NAME MANAGER
FROM EMPLOYEE E1, EMPLOYEE E2
WHERE E1.MANAGER_ID = E2.EMP_ID;

--CROSS JOIN WITH EVERY EMPLOYEE AND DEPARTMENT
SELECT EMP_NAME, DEPT_NAME
FROM EMPLOYEE
CROSS JOIN DEPARTMENT;

--NATURAL JOIN RETURNS ALL RECORDS, WHETHER IN COMMON OR NOT, BUT WITH NO DUPLICATED COLUMNS
SELECT *
FROM EMPLOYEE
NATURAL JOIN DEPARTMENT;

--NATURAL VS INNER JOIN
SELECT *
FROM EMPLOYEE
JOIN DEPARTMENT
ON EMPLOYEE.DEPT_ID = DEPARTMENT.DEPT_ID;

SELECT *
FROM LOCATIONS
FULL JOIN EMPLOYEE
ON EMPLOYEE.SITE_ID = LOCATIONS.SITE_ID;

--WE CAN "STACK JOINS AND JOIN FROM MORE THAN ONE TABLE, QUERYING INFORMATION FROM ALL THREE
--SOME FUN WITH CONCAT
SELECT
    E.EMP_NAME NAME,
    D.DEPT_NAME DEPARTMENT,
    CONCAT(CONCAT(L.SITE_CITY, ', '), L.SITE_STATE) LOCATION
FROM EMPLOYEE E
INNER JOIN DEPARTMENT D
ON E.DEPT_ID = D.DEPT_ID
INNER JOIN LOCATIONS L
ON L.SITE_ID = E.SITE_ID;

--UNION
SELECT *
FROM EMPLOYEE
WHERE DEPT_ID = 1
UNION
SELECT *
FROM EMPLOYEE
WHERE SITE_ID = 1;

--UNION ALL
SELECT *
FROM EMPLOYEE
WHERE DEPT_ID = 1
UNION ALL
SELECT *
FROM EMPLOYEE
WHERE SITE_ID = 1;

--INTERSECTS
SELECT *
FROM EMPLOYEE
WHERE DEPT_ID = 1
INTERSECT
SELECT *
FROM EMPLOYEE
WHERE SITE_ID = 1;

--MINUS
SELECT *
FROM EMPLOYEE
WHERE DEPT_ID = 1
MINUS
SELECT *
FROM EMPLOYEE
WHERE SITE_ID = 1;

-------------------------------------
--USING IN AND EXISTS WITH SUBQUERIES
-------------------------------------
--GIVES US DEPARTMENTS THAT HAVE EMPLOYEES
SELECT *
FROM DEPARTMENT
WHERE DEPT_ID IN (
    SELECT DEPT_ID
    FROM EMPLOYEE
);
    
SELECT *
FROM DEPARTMENT
WHERE EXISTS (
    SELECT *
    FROM EMPLOYEE
    WHERE EMPLOYEE.DEPT_ID = DEPARTMENT.DEPT_ID
);

/*EXISTS VS IN
"EXISTS" IS GOING TO EVALUATE TO A BOOLEAN, WHEREAS "IN" IS GOING TO RETURN A RESULT
"EXISTS" RUNS THE INNER QUERY ONCE FOR EVERY RECORD IN THE OUTER QUERY; IF OUTER QUERY IS EXPECTED TO HAVE MORE
RESULTS THAN INNER QUERY, THIS IS INEFFICIENT
IN IS MORE USEFUL THEN (AND IN GENERAL)
*/

------------------------------------------------------
--DAY 2 AFTER LUNCH
------------------------------------------------------
COMMIT;
--PRINTS THINGS AS THEY WERE LAST SAVED
SELECT SITE_STREET STREET1, SITE_CITY CITY1, SITE_STATE STATE1
FROM LOCATIONS;

SAVEPOINT SP1;

--SETS ALL CITIES TO KANSAS CITY
UPDATE LOCATIONS
SET SITE_CITY = 'KANSAS CITY';


SELECT SITE_STREET STREET2, SITE_CITY CITY2, SITE_STATE STATE2
FROM LOCATIONS;
ROLLBACK TO SP1;

UPDATE LOCATIONS
SET SITE_CITY = 'OKLAHOMA CITY'
WHERE SITE_ID = 3;
SELECT SITE_STREET STREET3, SITE_CITY CITY3, SITE_STATE STATE3
FROM LOCATIONS;

ROLLBACK;
COMMIT;
SELECT SITE_STREET STREET4, SITE_CITY CITY4, SITE_STATE STAT4
FROM LOCATIONS;

--AUTO COMMITS OUR DML (INSERT, UPDATE, DELETE)
--SET AUTOCOMMIT ON
--SET AUTOCOMMIT OFF

-------------------------------------------------------------------------------------------------------------
--TUESDAY INDEPENDENT CLASSWORK
---------------------------------------------------------------------------------------------------------------

--Create a table INVOICE which includes an id, date, customer id, and amount
CREATE TABLE INVOICE (
    INV_ID NUMBER(5) CONSTRAINT PK_INVOICE PRIMARY KEY,
    INV_DATE DATE,
    CUST_ID NUMBER(5),
    AMOUNT NUMBER(7,2)
    );
    
ALTER TABLE INVOICE
DROP CONSTRAINT PK_INVOICE;
--Create a table CUSTOMER which includes relevant customer information 
CREATE TABLE CUSTOMER (
    CUST_ID NUMBER(5) CONSTRAINT PK_CUSTOMER PRIMARY KEY,
    CUST_FNAME VARCHAR2(20),
    CUST_LNAME VARCHAR2(30),
    CUST_EMAIL VARCHAR2(50),
    CUST_PHONENUM NUMBER(10)
);

insert into CUSTOMER (CUST_ID, CUST_FNAME, CUST_LNAME, CUST_EMAIL, CUST_PHONENUM) values (1, 'Tam', 'Wallentin', 'twallentin0@surveymonkey.com', 4547504906);
insert into CUSTOMER (CUST_ID, CUST_FNAME, CUST_LNAME, CUST_EMAIL, CUST_PHONENUM) values (2, 'Muriel', 'McGaughey', 'mmcgaughey1@delicious.com', 6384047544);
insert into CUSTOMER (CUST_ID, CUST_FNAME, CUST_LNAME, CUST_EMAIL, CUST_PHONENUM) values (3, 'Cirstoforo', 'Cubbin', 'ccubbin2@engadget.com', 4313698647);
insert into CUSTOMER (CUST_ID, CUST_FNAME, CUST_LNAME, CUST_EMAIL, CUST_PHONENUM) values (4, 'Robers', 'Spensley', 'rspensley3@whitehouse.gov', 6549914896);
insert into CUSTOMER (CUST_ID, CUST_FNAME, CUST_LNAME, CUST_EMAIL, CUST_PHONENUM) values (5, 'Feliks', 'Skillern', 'fskillern4@friendfeed.com', 3472472341);
insert into CUSTOMER (CUST_ID, CUST_FNAME, CUST_LNAME, CUST_EMAIL, CUST_PHONENUM) values (6, 'Imelda', 'Yu', 'iyu5@wikimedia.org', 9918169371);
insert into CUSTOMER (CUST_ID, CUST_FNAME, CUST_LNAME, CUST_EMAIL, CUST_PHONENUM) values (7, 'Cooper', 'Vasilchenko', 'cvasilchenko6@t.co', 8493593300);
insert into CUSTOMER (CUST_ID, CUST_FNAME, CUST_LNAME, CUST_EMAIL, CUST_PHONENUM) values (8, 'Terrell', 'Cadd', 'tcadd7@soundcloud.com', 6457050930);
insert into CUSTOMER (CUST_ID, CUST_FNAME, CUST_LNAME, CUST_EMAIL, CUST_PHONENUM) values (9, 'Marybelle', 'Canter', 'mcanter8@ted.com', 5723563439);
insert into CUSTOMER (CUST_ID, CUST_FNAME, CUST_LNAME, CUST_EMAIL, CUST_PHONENUM) values (10, 'Freddie', 'Braisted', 'fbraisted9@gnu.org', 2979862783);

DROP TABLE CUSTOMER;

SELECT * 
FROM CUSTOMER;
 


ALTER TABLE INVOICE
ADD CONSTRAINT FK_CUST_ID FOREIGN KEY (CUST_ID) REFERENCES CUSTOMER;

--Insert at least 50 records into your invoice table and at least 10 records into your customer table
insert into INVOICE (INV_ID, INV_DATE, CUST_ID, AMOUNT) values (1, DATE '2017-11-29', 2, 489.63);
insert into INVOICE (INV_ID, INV_DATE, CUST_ID, AMOUNT) values (2, DATE '2018-01-18', 10, 301.01);
insert into INVOICE (INV_ID, INV_DATE, CUST_ID, AMOUNT) values (3, DATE '2017-12-10', 4, 403.75);
insert into INVOICE (INV_ID, INV_DATE, CUST_ID, AMOUNT) values (4, DATE '2018-05-30', 10, 288.71);
insert into INVOICE (INV_ID, INV_DATE, CUST_ID, AMOUNT) values (5, DATE '2017-11-02', 5, 336.25);
insert into INVOICE (INV_ID, INV_DATE, CUST_ID, AMOUNT) values (6, DATE '2018-05-25', 2, 131.68);
insert into INVOICE (INV_ID, INV_DATE, CUST_ID, AMOUNT) values (7, DATE '2018-06-28', 7, 65.39);
insert into INVOICE (INV_ID, INV_DATE, CUST_ID, AMOUNT) values (8, DATE '2017-11-29', 9, 330.97);
insert into INVOICE (INV_ID, INV_DATE, CUST_ID, AMOUNT) values (9, DATE '2017-09-15', 7, 56.94);
insert into INVOICE (INV_ID, INV_DATE, CUST_ID, AMOUNT) values (10, DATE '2017-12-29', 7, 342.9);
insert into INVOICE (INV_ID, INV_DATE, CUST_ID, AMOUNT) values (1, DATE '2018-08-07', 6, 475.16);
insert into INVOICE (INV_ID, INV_DATE, CUST_ID, AMOUNT) values (2, DATE '2017-09-29', 6, 85.56);
insert into INVOICE (INV_ID, INV_DATE, CUST_ID, AMOUNT) values (3, DATE '2018-07-15', 8, 493.47);
insert into INVOICE (INV_ID, INV_DATE, CUST_ID, AMOUNT) values (4, DATE '2018-06-02', 9, 172.04);
insert into INVOICE (INV_ID, INV_DATE, CUST_ID, AMOUNT) values (5, DATE '2018-07-23', 6, 207.87);
insert into INVOICE (INV_ID, INV_DATE, CUST_ID, AMOUNT) values (6, DATE '2018-03-03', 1, 5.21);
insert into INVOICE (INV_ID, INV_DATE, CUST_ID, AMOUNT) values (7, DATE '2018-08-06', 2, 143.09);
insert into INVOICE (INV_ID, INV_DATE, CUST_ID, AMOUNT) values (8, DATE '2018-07-31', 2, 289.97);
insert into INVOICE (INV_ID, INV_DATE, CUST_ID, AMOUNT) values (9, DATE '2018-07-20', 2, 51.54);
insert into INVOICE (INV_ID, INV_DATE, CUST_ID, AMOUNT) values (10, DATE '2018-01-11', 1, 1.33);
insert into INVOICE (INV_ID, INV_DATE, CUST_ID, AMOUNT) values (11, DATE '2018-04-29', 6, 426.51);
insert into INVOICE (INV_ID, INV_DATE, CUST_ID, AMOUNT) values (12, DATE '2018-02-11', 2, 252.98);
insert into INVOICE (INV_ID, INV_DATE, CUST_ID, AMOUNT) values (13, DATE '2018-01-02', 4, 101.48);
insert into INVOICE (INV_ID, INV_DATE, CUST_ID, AMOUNT) values (14, DATE '2018-02-15', 3, 315.03);
insert into INVOICE (INV_ID, INV_DATE, CUST_ID, AMOUNT) values (15, DATE '2018-01-28', 2, 194.41);
insert into INVOICE (INV_ID, INV_DATE, CUST_ID, AMOUNT) values (16, DATE '2018-03-18', 6, 53.16);
insert into INVOICE (INV_ID, INV_DATE, CUST_ID, AMOUNT) values (17, DATE '2017-11-24', 6, 272.54);
insert into INVOICE (INV_ID, INV_DATE, CUST_ID, AMOUNT) values (18, DATE '2018-01-25', 10, 418.31);
insert into INVOICE (INV_ID, INV_DATE, CUST_ID, AMOUNT) values (19, DATE '2017-10-30', 9, 489.09);
insert into INVOICE (INV_ID, INV_DATE, CUST_ID, AMOUNT) values (20, DATE '2017-11-09', 7, 334.08);
insert into INVOICE (INV_ID, INV_DATE, CUST_ID, AMOUNT) values (21, DATE '2018-08-12', 5, 108.54);
insert into INVOICE (INV_ID, INV_DATE, CUST_ID, AMOUNT) values (22, DATE '2018-07-21', 9, 83.37);
insert into INVOICE (INV_ID, INV_DATE, CUST_ID, AMOUNT) values (23, DATE '2017-11-18', 9, 487.08);
insert into INVOICE (INV_ID, INV_DATE, CUST_ID, AMOUNT) values (24, DATE '2018-01-13', 3, 268.65);
insert into INVOICE (INV_ID, INV_DATE, CUST_ID, AMOUNT) values (25, DATE '2018-06-15', 7, 113.47);
insert into INVOICE (INV_ID, INV_DATE, CUST_ID, AMOUNT) values (26, DATE '2018-02-01', 6, 8.07);
insert into INVOICE (INV_ID, INV_DATE, CUST_ID, AMOUNT) values (27, DATE '2018-03-19', 1, 270.77);
insert into INVOICE (INV_ID, INV_DATE, CUST_ID, AMOUNT) values (28, DATE '2018-01-31', 4, 185.87);
insert into INVOICE (INV_ID, INV_DATE, CUST_ID, AMOUNT) values (29, DATE '2017-11-04', 8, 293.22);
insert into INVOICE (INV_ID, INV_DATE, CUST_ID, AMOUNT) values (30, DATE '2018-04-06', 1, 465.13);
insert into INVOICE (INV_ID, INV_DATE, CUST_ID, AMOUNT) values (31, DATE '2017-09-23', 8, 215.12);
insert into INVOICE (INV_ID, INV_DATE, CUST_ID, AMOUNT) values (32, DATE '2017-09-12', 1, 127.68);
insert into INVOICE (INV_ID, INV_DATE, CUST_ID, AMOUNT) values (33, DATE '2017-11-22', 5, 170.5);
insert into INVOICE (INV_ID, INV_DATE, CUST_ID, AMOUNT) values (34, DATE '2017-09-06', 6, 212.49);
insert into INVOICE (INV_ID, INV_DATE, CUST_ID, AMOUNT) values (35, DATE '2018-07-07', 3, 139.46);
insert into INVOICE (INV_ID, INV_DATE, CUST_ID, AMOUNT) values (36, DATE '2017-12-25', 10, 291.48);
insert into INVOICE (INV_ID, INV_DATE, CUST_ID, AMOUNT) values (37, DATE '2018-07-01', 9, 86.26);
insert into INVOICE (INV_ID, INV_DATE, CUST_ID, AMOUNT) values (38, DATE '2018-01-02', 6, 321.62);
insert into INVOICE (INV_ID, INV_DATE, CUST_ID, AMOUNT) values (39, DATE '2018-08-22', 5, 144.47);
insert into INVOICE (INV_ID, INV_DATE, CUST_ID, AMOUNT) values (40, DATE '2018-02-15', 9, 10.37);
insert into INVOICE (INV_ID, INV_DATE, CUST_ID, AMOUNT) values (40, DATE '2018-08-22', 9, 10.37);

SELECT *
FROM INVOICE;

--***
UPDATE INVOICE
SET CUST_ID = NULL
WHERE AMOUNT = 342.9;


COMMIT;

SELECT *
FROM CUSTOMER;
--Create a query which shows purchases that occured today
SELECT * 
FROM INVOICE
WHERE INV_DATE = TRUNC(CURRENT_DATE);

SELECT * 
FROM INVOICE
WHERE INV_DATE = DATE '2018-08-22';
--SELECT CURDATE(); why won't my getdate() functions work????

--SELECT CONVERT(VARCHAR, GETDATE(), 1);

--CURDATE();
--Create a query which shows each customer and the number of purchases made by each
SELECT CUST_ID, COUNT(INV_ID) AS NUM_PURCHASES
FROM INVOICE
GROUP BY CUST_ID
ORDER BY CUST_ID;

--Create a query which shows each customer and the total cost of all their purchases
SELECT CUST_ID, SUM(AMOUNT)
FROM INVOICE
GROUP BY CUST_ID; 

--Create a query which returns all purchases which took place in the last month, display them in descending order
SELECT *
FROM INVOICE
WHERE INV_DATE > DATE '2018-07-21'
ORDER BY INV_DATE DESC;

--Create a query which show the top three most expensive purchases
SELECT *
FROM INVOICE
WHERE ROWNUM < 4
ORDER BY AMOUNT DESC;

--TO CHECK THAT IT IS MAX VALUE
SELECT *
FROM INVOICE
WHERE AMOUNT = 
    (SELECT MAX(AMOUNT)
        FROM INVOICE);

/*
Create a query which returns all of the invoices which have a listed customer, 
but not invoices who have no customer listed and not customers who have no invoices listed 
\
*/
SELECT *    
FROM INVOICE I, CUSTOMER C
WHERE I.CUST_ID = C.CUST_ID;

/*Create a query which returns all of the invoices and their customer, 
not invoices who have no customer listed but include customers which have no invoices listed
*/
SELECT 
    I.INV_ID INVOICE_ID,
    I.INV_DATE INVOICE_DATE,
    I.AMOUNT AMOUNT,
    I.CUST_ID CUSTOMER_ID
    FROM INVOICE I
RIGHT JOIN CUSTOMER C
ON I.CUST_ID = C.CUST_ID
ORDER BY INV_ID;
   
--Create a query which shows each record in the invoice table, along with the name of the customer
SELECT 
    C.CUST_FNAME,
    C.CUST_LNAME,
    I.*
FROM INVOICE I, CUSTOMER C
WHERE I.CUST_ID = C.CUST_ID
ORDER BY c.cust_lname;

--Create a query which shows the name of each customer and the total amount they have spent
SELECT CUST_FNAME, CUST_LNAME, TOTAL
FROM( 
       SELECT 
        C.CUST_ID,
        SUM(I.AMOUNT) AS TOTAL
        FROM INVOICE I, CUSTOMER C
        WHERE I.CUST_ID = C.CUST_ID
        GROUP BY C.CUST_ID) CUSTOMER_INVOICE   
JOIN CUSTOMER C
ON C.CUST_ID = CUSTOMER_INVOICE.CUST_ID;

--Create a query which returns the record of the customer who made the most recent purchase
SELECT 
    C.*
    FROM CUSTOMER C, INVOICE I
    WHERE C.CUST_ID = I.CUST_ID
    ORDER BY I.INV_DATE DESC;


SELECT MAX(INV_DATE)
FROM INVOICE;

/*
Create a query which shows the purchaser of each invoice and the subtotal of each invoice if 
6% sales tax was applied to the subtotal to get the price of each invoice
*/

SELECT I.INV_ID, ROUND((I.AMOUNT/1.06),2) SUBTOTAL, C.*
FROM INVOICE I, CUSTOMER C
WHERE I.CUST_ID = C.CUST_ID
ORDER BY I.INV_ID;

